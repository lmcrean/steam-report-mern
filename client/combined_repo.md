# Repo as one markdown file

This file was generated by the repo-to-one-file package, find it here: 

 [GitHub](https://github.com/tonypls/repo-to-one-file-cli) 

 [NPM](https://www.npmjs.com/package/repo-to-one-file)

# Directory Structure

```
.eslintrc.cjs
index.html
package.json
playwright-report/
  data/
    02956bb55b4e952b23f295ea28797adc86048f2e.zip
    2956737e9c74efff3d7f9bb3d27e59a2a9738c79.zip
    6abc3753585c9a215478bf924e7e71599adc88d4.zip
    7b688b8af43c70dacf98925887ec7a9d60f049fd.png
    9a44ec0c0fb31ca4c9500852e174687d3e6661a4.png
    a019bba5da86de037ab2cf4f90f2ec9125ee4abf.png
  index.html
  trace/
    assets/
      codeMirrorModule-Bh1rfd2w.js
      inspectorTab-7GHnKvSD.js
      testServerConnection-DeE2kSzz.js
      workbench-DPQnTHYP.js
    codeMirrorModule.ez37Vkbh.css
    codicon.DCmgc-ay.ttf
    embedded.BlHoW5LY.js
    embedded.html
    embedded.w7WN2u1R.css
    index.CrbWWHbf.css
    index.DaWVfou1.js
    index.html
    inspectorTab.DLjBDrQR.css
    playwright-logo.svg
    recorder.B_SY1GJM.css
    recorder.C4zxcvd2.js
    recorder.html
    snapshot.html
    uiMode.CAYqod-m.css
    uiMode.html
    uiMode.mTXWniJb.js
    workbench.D3JVcA9K.css
    xtermModule.DSXBckUd.css
playwright.config.js
postcss.config.js
public/
  tailwind.svg
  vite.svg
screenshots/
  homepage/
    2xl-1536px-2024-10-28T21-15-14-617Z.png
    lg-1024px-2024-10-28T21-15-14-617Z.png
    md-768px-2024-10-28T21-15-14-617Z.png
    sm-640px-2024-10-28T21-15-14-617Z.png
    xl-1280px-2024-10-28T21-15-14-617Z.png
    xs-375px-2024-10-28T21-15-14-617Z.png
src/
  App.css
  App.jsx
  assets/
    react.svg
  components/
    layout/
      Header.jsx
      MainLayout.jsx
    quiz/
      MenuScreen.jsx
      PersonalityQuiz.jsx
      QuizLeaderboard.jsx
      QuizResults.jsx
      SubjectQuiz.jsx
      UsernameEntry.jsx
    shared/
      Alert.jsx
      LoadingSpinner.jsx
      ProgressBar.jsx
      QuizCard.jsx
      QuizNavigation.jsx
      RadioGroup.jsx
  context/
    QuizContext.jsx
  data/
    feedbackDatabase.js
    personalityQuestions.js
    subjectQuestions.js
  hooks/
    useLocalStorage.js
    useQuizState.js
  index.css
  main.jsx
  utils/
    scoreCalculator.js
    validators.js
tailwind.config.js
test-results/
  quizflow-Quiz-Application-Flow-complete-quiz-journey-chromium/
    test-failed-1.png
    trace.zip
  quizflow-Quiz-Application-Flow-quiz-navigation-controls-chromium/
    test-failed-1.png
    trace.zip
  quizflow-Quiz-Application-Flow-username-validation-chromium/
    test-failed-1.png
    trace.zip
tests/
  example.spec.js
  quizflow.spec.js
  responsive.spec.js
  utils/
    screenshot.js
tests-examples/
  demo-todo-app.spec.js
vite.config.js
```

## package.json

```json
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --port 3000",
    "build": "vite build",
    "lint": "eslint src --ext js,jsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "test": "playwright test --ui"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "repo-to-one-file": "^1.0.2",
    "tailwind": "^4.0.0"
  },
  "devDependencies": {
    "@playwright/test": "^1.48.2",
    "@types/node": "^22.8.1",
    "@types/react": "^18.0.28",
    "@types/react-dom": "^18.0.11",
    "@vitejs/plugin-react": "^4.0.0",
    "autoprefixer": "^10.4.20",
    "eslint": "^8.38.0",
    "eslint-plugin-react": "^7.32.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.3.4",
    "playwright": "^1.48.2",
    "postcss": "^8.4.47",
    "postcss-import": "^16.1.0",
    "tailwindcss": "^3.4.14",
    "vite": "^4.3.2"
  }
}

```

## playwright.config.js

```js
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests',
  /* Maximum time one test can run for */
  timeout: 30 * 1000,
  expect: {
    timeout: 5000
  },
  /* Run tests in files in parallel */
  fullyParallel: true,
  /* Fail the build on CI if you accidentally left test.only in the source code. */
  forbidOnly: !!process.env.CI,
  /* Retry on CI only */
  retries: process.env.CI ? 2 : 0,
  /* Opt out of parallel tests on CI. */
  workers: process.env.CI ? 1 : undefined,
  /* Reporter to use. See https://playwright.dev/docs/test-reporters */
  reporter: 'html',
  
  /* Configure projects for major browsers */
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],

  /* Run your local dev server before starting the tests */
  webServer: {
    command: 'npm run dev',
    port: 3001,
    reuseExistingServer: !process.env.CI,
  },

  use: {
    /* Base URL to use in actions like `await page.goto('/')`. */
    baseURL: 'http://localhost:3001',
    /* Collect trace when retrying the failed test */
    trace: 'on-first-retry',
    /* Take screenshot on failure */
    screenshot: 'only-on-failure',
  },
});
```

## postcss.config.js

```js
export default {
  plugins: {
    'postcss-import': {},
    'tailwindcss/nesting': {},
    'tailwindcss': {},
    'autoprefixer': {},
  }
}

```

## src\App.jsx

```jsx
import React from 'react';
import MainLayout from './components/layout/MainLayout';
import Header from './components/layout/Header';
import MenuScreen from './components/quiz/MenuScreen';
import PersonalityQuiz from './components/quiz/PersonalityQuiz';
import SubjectQuiz from './components/quiz/SubjectQuiz';
import QuizResults from './components/quiz/QuizResults';
import QuizLeaderboard from './components/quiz/QuizLeaderboard';
import UsernameEntry from './components/quiz/UsernameEntry'; 
import { QuizProvider, useQuiz } from './context/QuizContext';
import './App.css';

// New component to handle quiz flow
const QuizFlow = () => {
  const { section } = useQuiz();

  const renderSection = () => {
    switch (section) {
      case 'menu':
        return <MenuScreen />;
      case 'username':
        return <UsernameEntry />;
      case 'personality':
        return <PersonalityQuiz />;
      case 'subject':
        return <SubjectQuiz />;
      case 'results':
        return <QuizResults />;
      case 'leaderboard':
        return <QuizLeaderboard />;
      default:
        return <MenuScreen />;
    }
  };

  return (
    <MainLayout>
      <Header title="STEAM Career Quiz" />
      <main className="flex-grow flex flex-col items-center justify-center p-6">
        <div className="w-full max-w-2xl">
          {renderSection()}
        </div>
      </main>
    </MainLayout>
  );
};

function App() {
  return (
    <QuizProvider>
      <QuizFlow />
    </QuizProvider>
  );
}

export default App;
```

## src\components\layout\Header.jsx

```jsx
import React from 'react';

const Header = ({ title }) => {
  return (
    <header className="py-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl sm:text-3xl font-bold text-gray-900 dark:text-white">
          {title}
        </h1>
      </div>
    </header>
  );
};

export default Header;
```

## src\components\layout\MainLayout.jsx

```jsx
import React from 'react';

const MainLayout = ({ children }) => {
  return (
    <div className="min-h-screen bg-gray-100 dark:bg-slate-900">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex flex-col min-h-screen">
          {children}
        </div>
      </div>
    </div>
  );
};

export default MainLayout;
```

## src\components\quiz\MenuScreen.jsx

```jsx
import React from 'react';
import { useQuiz } from '../../context/QuizContext';
import QuizCard from '../shared/QuizCard';

const MenuScreen = () => {
  const { setSection } = useQuiz();

  const menuItems = [
    {
      title: 'Start Quiz',
      description: 'Begin your STEAM career discovery journey',
      action: () => setSection('username'),
      primary: true
    },
    {
      title: 'About OCEAN Test',
      description: 'Learn about the personality assessment',
      action: () => setSection('about-ocean')
    },
    {
      title: 'About STEAM',
      description: 'Understand the subject areas',
      action: () => setSection('about-steam')
    },
    {
      title: 'How to Play',
      description: 'Get guidance on taking the quiz',
      action: () => setSection('how-to-play')
    }
  ];

  return (
    <QuizCard title="Welcome to STEAM Career Quiz">
      <div className="space-y-4">
        <p className="text-gray-600 dark:text-gray-300 mb-6">
          Discover your ideal career path through personality assessment and subject knowledge evaluation.
        </p>
        
        <div className="grid gap-4 sm:grid-cols-2">
          {menuItems.map((item, index) => (
            <button
              key={index}
              onClick={item.action}
              className={`
                p-4 rounded-lg text-left transition-all duration-200
                ${item.primary 
                  ? 'bg-blue-600 hover:bg-blue-700 text-white'
                  : 'bg-gray-50 dark:bg-slate-700 hover:bg-gray-100 dark:hover:bg-slate-600 text-gray-900 dark:text-white'}
              `}
            >
              <h3 className="font-semibold mb-1">
                {item.title}
              </h3>
              <p className={`text-sm ${item.primary ? 'text-blue-100' : 'text-gray-500 dark:text-gray-400'}`}>
                {item.description}
              </p>
            </button>
          ))}
        </div>
      </div>
    </QuizCard>
  );
};

export default MenuScreen;
```

## src\components\quiz\PersonalityQuiz.jsx

```jsx
import React from 'react';
import { useQuiz } from '../../context/QuizContext';
import ProgressBar from '../shared/ProgressBar';

const PersonalityQuiz = () => {
  const { progress, setProgress, answers, setAnswers } = useQuiz();

  return (
    <div className="space-y-6">
      <ProgressBar progress={progress} total={25} />
      <div className="bg-white dark:bg-slate-800 rounded-lg p-6 shadow-sm">
        <h2 className="text-xl font-semibold mb-4">
          OCEAN Personality Test
        </h2>
        {/* Quiz content will be added here */}
      </div>
    </div>
  );
};

export default PersonalityQuiz;
```

## src\components\quiz\QuizLeaderboard.jsx

```jsx
import React from 'react';

const QuizLeaderboard = () => {
  return (
    <div className="space-y-6">
      <div className="bg-white dark:bg-slate-800 rounded-lg p-6 shadow-sm">
        <h2 className="text-xl font-semibold mb-4">
          Leaderboard
        </h2>
        <div className="overflow-x-auto">
          <table className="min-w-full">
            <thead>
              <tr className="border-b dark:border-gray-700">
                <th className="px-4 py-2 text-left">Rank</th>
                <th className="px-4 py-2 text-left">Username</th>
                <th className="px-4 py-2 text-left">Score</th>
                <th className="px-4 py-2 text-left">Best Subject</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
              {/* Leaderboard entries will be added here */}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
};

export default QuizLeaderboard;
```

## src\components\quiz\QuizResults.jsx

```jsx
import React from 'react';

const QuizResults = () => {
  return (
    <div className="space-y-6">
      <div className="bg-white dark:bg-slate-800 rounded-lg p-6 shadow-sm">
        <h2 className="text-xl font-semibold mb-4">
          Your Results
        </h2>
        {/* Results content will be added here */}
      </div>
    </div>
  );
};

export default QuizResults;
```

## src\components\quiz\SubjectQuiz.jsx

```jsx
import React from 'react';
import { useQuiz } from '../../context/QuizContext';
import ProgressBar from '../shared/ProgressBar';

const SubjectQuiz = () => {
  const { progress, setProgress, answers, setAnswers } = useQuiz();

  return (
    <div className="space-y-6">
      <ProgressBar progress={progress} total={50} />
      <div className="bg-white dark:bg-slate-800 rounded-lg p-6 shadow-sm">
        <h2 className="text-xl font-semibold mb-4">
          STEAM Subject Quiz
        </h2>
        {/* Quiz content will be added here */}
      </div>
    </div>
  );
};

export default SubjectQuiz;
```

## src\components\quiz\UsernameEntry.jsx

```jsx
import React, { useState } from 'react';
import { useQuiz } from '../../context/QuizContext';
import QuizCard from '../shared/QuizCard';
import Alert from '../shared/Alert';
import { validateUsername } from '../../utils/validators';

const UsernameEntry = () => {
  const { setUsername, moveToNextSection } = useQuiz();
  const [inputValue, setInputValue] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    const validation = validateUsername(inputValue);
    
    if (!validation.isValid) {
      setError(validation.error);
      return;
    }

    setUsername(inputValue);
    moveToNextSection();
  };

  return (
    <QuizCard title="Enter Your Username">
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label 
            htmlFor="username" 
            className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
          >
            Username
          </label>
          <input
            type="text"
            id="username"
            placeholder="Enter your username"
            value={inputValue}
            onChange={(e) => {
              setInputValue(e.target.value);
              setError('');
            }}
            className="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md 
                     focus:ring-2 focus:ring-blue-500 dark:bg-slate-700"
          />
          {error && <Alert type="error">{error}</Alert>}
        </div>

        <div className="flex justify-end">
          <button
            type="submit"
            className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 
                     transition-colors"
          >
            Continue
          </button>
        </div>
      </form>
    </QuizCard>
  );
};

export default UsernameEntry;
```

## src\components\shared\Alert.jsx

```jsx
import React from 'react';

const alertStyles = {
  success: 'bg-green-50 text-green-800 dark:bg-green-900/50 dark:text-green-300',
  error: 'bg-red-50 text-red-800 dark:bg-red-900/50 dark:text-red-300',
  warning: 'bg-yellow-50 text-yellow-800 dark:bg-yellow-900/50 dark:text-yellow-300',
  info: 'bg-blue-50 text-blue-800 dark:bg-blue-900/50 dark:text-blue-300'
};

const Alert = ({ 
  type = 'info', 
  title, 
  children,
  onClose 
}) => {
  return (
    <div className={`rounded-lg p-4 mb-4 ${alertStyles[type]}`}>
      <div className="flex items-start">
        <div className="flex-1">
          {title && (
            <h3 className="text-sm font-medium mb-1">
              {title}
            </h3>
          )}
          <div className="text-sm">
            {children}
          </div>
        </div>
        {onClose && (
          <button
            onClick={onClose}
            className="ml-3 inline-flex flex-shrink-0 justify-center items-center h-5 w-5 rounded-full hover:bg-black/5 dark:hover:bg-white/5 transition-colors"
          >
            <span className="sr-only">Close</span>
            <svg className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        )}
      </div>
    </div>
  );
};

export default Alert;
```

## src\components\shared\LoadingSpinner.jsx

```jsx
import React from 'react';

const LoadingSpinner = () => {
  return (
    <div className="flex justify-center items-center">
      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600" />
    </div>
  );
};

export default LoadingSpinner;
```

## src\components\shared\ProgressBar.jsx

```jsx
import React from 'react';

const ProgressBar = ({ progress, total }) => {
  const percentage = (progress / total) * 100;
  
  return (
    <div className="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
      <div 
        className="bg-blue-600 h-2.5 rounded-full transition-all duration-300"
        style={{ width: `${percentage}%` }}
      />
    </div>
  );
};

export default ProgressBar;
```

## src\components\shared\QuizCard.jsx

```jsx
import React from 'react';

const QuizCard = ({ 
  title, 
  children, 
  footer,
  className = "" 
}) => {
  return (
    <div className={`w-full max-w-2xl mx-auto ${className}`}>
      <div className="bg-white dark:bg-slate-800 rounded-xl shadow-lg overflow-hidden">
        {title && (
          <div className="px-6 py-4 bg-gray-50 dark:bg-slate-700 border-b border-gray-200 dark:border-slate-600">
            <h2 className="text-xl font-semibold text-gray-900 dark:text-white">
              {title}
            </h2>
          </div>
        )}
        
        <div className="p-6">
          {children}
        </div>

        {footer && (
          <div className="px-6 py-4 bg-gray-50 dark:bg-slate-700 border-t border-gray-200 dark:border-slate-600">
            {footer}
          </div>
        )}
      </div>
    </div>
  );
};

export default QuizCard;
```

## src\components\shared\QuizNavigation.jsx

```jsx
import React from 'react';

const QuizNavigation = ({ onNext, onPrev, canProgress, showPrev = true }) => {
  return (
    <div className="flex justify-between mt-6">
      {showPrev && (
        <button
          onClick={onPrev}
          className="btn btn-secondary"
        >
          Previous
        </button>
      )}
      <button
        onClick={onNext}
        disabled={!canProgress}
        className={`btn btn-primary disabled:opacity-50 ${!showPrev ? 'ml-auto' : ''}`}
      >
        Next
      </button>
    </div>
  );
};

export default QuizNavigation;
```

## src\components\shared\RadioGroup.jsx

```jsx
import React from 'react';

const RadioGroup = ({ 
  options, 
  value, 
  onChange, 
  name,
  orientation = 'vertical'
}) => {
  const layoutClass = orientation === 'vertical' 
    ? 'flex flex-col space-y-3'
    : 'flex flex-row justify-between space-x-4';

  return (
    <div className={layoutClass}>
      {options.map((option) => (
        <label
          key={option.value}
          className={`
            relative flex items-center p-4 cursor-pointer
            bg-gray-50 dark:bg-slate-700 rounded-lg
            border-2 transition-all duration-200
            ${value === option.value 
              ? 'border-blue-500 dark:border-blue-400' 
              : 'border-gray-200 dark:border-slate-600 hover:border-gray-300 dark:hover:border-slate-500'}
          `}
        >
          <input
            type="radio"
            name={name}
            value={option.value}
            checked={value === option.value}
            onChange={() => onChange(option.value)}
            className="sr-only"
          />
          <div className="flex-1">
            <div className="flex justify-between">
              <div className="text-sm font-medium text-gray-900 dark:text-white">
                {option.label}
              </div>
              {option.score !== undefined && (
                <div className="text-sm text-gray-500 dark:text-gray-400">
                  {option.score}
                </div>
              )}
            </div>
            {option.description && (
              <div className="mt-1 text-sm text-gray-500 dark:text-gray-400">
                {option.description}
              </div>
            )}
          </div>
        </label>
      ))}
    </div>
  );
};

export default RadioGroup;
```

## src\context\QuizContext.jsx

```jsx
import React, { createContext, useContext, useState } from 'react';

const QuizContext = createContext(null);

export const useQuiz = () => {
  const context = useContext(QuizContext);
  if (!context) {
    throw new Error('useQuiz must be used within a QuizProvider');
  }
  return context;
};

export const QuizProvider = ({ children }) => {
  const [section, setSection] = useState('menu');
  const [username, setUsername] = useState('');
  const [progress, setProgress] = useState(0);
  const [personalityAnswers, setPersonalityAnswers] = useState([]);
  const [subjectAnswers, setSubjectAnswers] = useState([]);
  const [results, setResults] = useState(null);

  const moveToNextSection = () => {
    const sections = ['menu', 'username', 'personality', 'subject', 'results', 'leaderboard'];
    const currentIndex = sections.indexOf(section);
    if (currentIndex < sections.length - 1) {
      setSection(sections[currentIndex + 1]);
    }
  };

  const moveToPreviousSection = () => {
    const sections = ['menu', 'username', 'personality', 'subject', 'results', 'leaderboard'];
    const currentIndex = sections.indexOf(section);
    if (currentIndex > 0) {
      setSection(sections[currentIndex - 1]);
    }
  };

  const value = {
    section,
    setSection,
    username,
    setUsername,
    progress,
    setProgress,
    personalityAnswers,
    setPersonalityAnswers,
    subjectAnswers,
    setSubjectAnswers,
    results,
    setResults,
    moveToNextSection,
    moveToPreviousSection
  };

  return (
    <QuizContext.Provider value={value}>
      {children}
    </QuizContext.Provider>
  );
};

export default QuizContext;
```

## src\data\feedbackDatabase.js

```js
export const feedbackDatabase = {
    "Science and Openness": {
      environment: "exploratory and innovative",
      careers: [
        "Research Scientist",
        "Innovation Lead",
        "Scientific Explorer",
        "R&D Specialist"
      ],
      feedback: "Your affinity for science combined with an open-minded approach suggests you'd excel in exploratory and innovative environments. Your curiosity and creativity will drive you forward in fields that value research and development."
    },
    "Technology and Conscientiousness": {
      environment: "structured and data-driven",
      careers: [
        "Systems Analyst",
        "Database Administrator",
        "Software Engineer",
        "Quality Assurance Lead"
      ],
      feedback: "Your technological aptitude combined with a conscientious nature suggests a structured and data-driven environment would suit you well. Your precision and organized workflow will be highly valued."
    },
    "English and Extraversion": {
      environment: "interactive and collaborative",
      careers: [
        "Content Strategist",
        "Communications Director",
        "Publishing Manager",
        "Public Relations"
      ],
      feedback: "Your English expertise combined with an extroverted personality makes an interactive and collaborative environment ideal for you. Your communication skills and team dynamics could shine."
    },
    "Art and Agreeableness": {
      environment: "supportive and community-focused",
      careers: [
        "Art Therapist",
        "Community Arts Director",
        "Design Team Lead",
        "Creative Workshop Facilitator"
      ],
      feedback: "Your artistic interests, paired with an agreeable nature, align well with supportive and community-focused environments. Your empathy and collaboration skills could make a real difference."
    },
    "Math and Neuroticism": {
      environment: "predictable and well-defined",
      careers: [
        "Data Analyst",
        "Financial Planner",
        "Risk Assessment Specialist",
        "Statistical Researcher"
      ],
      feedback: "With a solid background in math and a detail-oriented nature, you may find comfort in predictable and well-defined environments. Your analytical skills could serve well in roles requiring precision."
    }
    // Additional combinations will be loaded from the JSON file
  };
  
  export const getCareerFeedback = (steamCategory, oceanTrait) => {
    const key = `${steamCategory} and ${oceanTrait}`;
    return feedbackDatabase[key] || {
      environment: "dynamic and adaptable",
      careers: ["Various career paths available"],
      feedback: "Your unique combination of skills and traits suggests you could succeed in various roles. Consider exploring positions that combine your technical abilities with your personality strengths."
    };
  };
```

## src\data\personalityQuestions.js

```js
export const personalityQuestions = [
    {
      trait: "Openness",
      statement: "I eagerly explore new hobbies and interests, even if they are outside my comfort zone."
    },
    {
      trait: "Conscientiousness",
      statement: "I meticulously plan my daily schedule and stick to it."
    },
    {
      trait: "Extraversion",
      statement: "I love attending parties and social gatherings to meet new people."
    },
    {
      trait: "Agreeableness",
      statement: "I frequently go out of my way to help friends and family in times of need."
    },
    {
      trait: "Neuroticism",
      statement: "I often find myself worrying about possible negative outcomes in the future."
    },
    // Additional questions will be loaded from the JSON file
  ];
  
  export const traitDescriptions = {
    Openness: "Reflects your willingness to embrace new experiences and ideas.",
    Conscientiousness: "Indicates your level of organization and attention to detail.",
    Extraversion: "Shows how energized you are by social interactions.",
    Agreeableness: "Represents your tendency to be cooperative and compassionate.",
    Neuroticism: "Reflects your emotional sensitivity and tendency to experience stress."
  };
```

## src\data\subjectQuestions.js

```js
export const subjects = {
    Science: {
      description: "Tests your understanding of scientific principles and natural phenomena.",
      icon: "ðŸ”¬"
    },
    Technology: {
      description: "Evaluates your knowledge of computers, software, and digital systems.",
      icon: "ðŸ’»"
    },
    English: {
      description: "Assesses your comprehension of literature and language.",
      icon: "ðŸ“š"
    },
    Art: {
      description: "Tests your knowledge of visual arts, design, and creativity.",
      icon: "ðŸŽ¨"
    },
    Math: {
      description: "Evaluates your mathematical and logical reasoning skills.",
      icon: "ðŸ”¢"
    }
  };
  
  // Questions will be loaded from the JSON files for each subject
  export const getSubjectQuestions = async (subject) => {
    try {
      const response = await fetch(`/src/data/trivia_${subject.toLowerCase()}.json`);
      const data = await response.json();
      return data.results;
    } catch (error) {
      console.error(`Error loading ${subject} questions:`, error);
      return [];
    }
  };
```

## src\hooks\useLocalStorage.js

```js
import { useState, useEffect } from 'react';

const useLocalStorage = (key, initialValue) => {
  // State to store our value
  // Pass initial state function to useState so logic is only executed once
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.log(error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function that persists the new value to localStorage
  const setValue = value => {
    try {
      // Allow value to be a function so we have same API as useState
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.log(error);
    }
  };

  return [storedValue, setValue];
};

export default useLocalStorage;
```

## src\hooks\useQuizState.js

```js
import { useState, useCallback } from 'react';

const useQuizState = (initialState = {}) => {
  const [quizState, setQuizState] = useState({
    currentSection: 'menu',
    personalityAnswers: [],
    subjectAnswers: [],
    currentQuestionIndex: 0,
    ...initialState
  });

  const updateQuizState = useCallback((updates) => {
    setQuizState(prev => ({
      ...prev,
      ...updates
    }));
  }, []);

  const resetQuiz = useCallback(() => {
    setQuizState({
      currentSection: 'menu',
      personalityAnswers: [],
      subjectAnswers: [],
      currentQuestionIndex: 0
    });
  }, []);

  return {
    quizState,
    updateQuizState,
    resetQuiz
  };
};

export default useQuizState;
```

## src\main.jsx

```jsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)

```

## src\utils\scoreCalculator.js

```js
export const calculatePersonalityScores = (answers) => {
    const scores = {
      Openness: 0,
      Conscientiousness: 0,
      Extraversion: 0,
      Agreeableness: 0,
      Neuroticism: 0
    };
  
    // Group answers by trait and calculate scores
    answers.forEach((answer, index) => {
      const trait = getTraitForQuestion(index);
      scores[trait] += answer;
    });
  
    return scores;
  };
  
  export const calculateSubjectScores = (answers) => {
    const scores = {
      Science: 0,
      Technology: 0,
      English: 0,
      Art: 0,
      Math: 0,
      Total: 0
    };
  
    // Calculate scores for each subject (10 questions each)
    answers.forEach((isCorrect, index) => {
      const subject = getSubjectForQuestion(index);
      if (isCorrect) {
        scores[subject]++;
        scores.Total++;
      }
    });
  
    return scores;
  };
  
  export const getTraitForQuestion = (questionIndex) => {
    // Map question indices to OCEAN traits
    const traitMapping = {
      0: 'Openness',
      1: 'Conscientiousness',
      2: 'Extraversion',
      3: 'Agreeableness',
      4: 'Neuroticism'
    };
  
    return traitMapping[questionIndex % 5];
  };
  
  export const getSubjectForQuestion = (questionIndex) => {
    // Map question indices to STEAM subjects
    if (questionIndex < 10) return 'Science';
    if (questionIndex < 20) return 'Technology';
    if (questionIndex < 30) return 'English';
    if (questionIndex < 40) return 'Art';
    return 'Math';
  };
  
  export const convertScoreToPercentage = (score, maxScore) => {
    return ((score / maxScore) * 100).toFixed(1);
  };
```

## src\utils\validators.js

```js
export const validateUsername = (username) => {
    if (!username) {
      return { isValid: false, error: 'Username is required' };
    }
  
    if (username.length < 3) {
      return { isValid: false, error: 'Username must be at least 3 characters long' };
    }
  
    if (username.length > 9) {
      return { isValid: false, error: 'Username must be less than 9 characters long' };
    }
  
    if (!username.match(/^[a-zA-Z0-9]+$/)) {
      return { isValid: false, error: 'Username must contain only letters and numbers' };
    }
  
    return { isValid: true, error: null };
  };
  
  export const validateQuizAnswer = (answer, type) => {
    if (type === 'personality') {
      const numAnswer = Number(answer);
      if (isNaN(numAnswer) || numAnswer < 1 || numAnswer > 9) {
        return { isValid: false, error: 'Answer must be between 1 and 9' };
      }
    } else if (type === 'subject') {
      if (typeof answer !== 'number' || answer < 0 || answer > 3) {
        return { isValid: false, error: 'Invalid answer selection' };
      }
    }
  
    return { isValid: true, error: null };
  };
  
  export const validateQuizProgress = (currentSection, answers) => {
    switch (currentSection) {
      case 'personality':
        return answers.length === 25;
      case 'subject':
        return answers.length === 50;
      default:
        return false;
    }
  };
```

## tailwind.config.js

```js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class', // or 'media' for system preferences
  theme: {
    extend: {
      screens: {
        'xs': '375px',
        'sm': '640px',
        'md': '768px',
        'lg': '1024px',
        'xl': '1280px',
        '2xl': '1536px',
      },
    },
  },
  plugins: [],
}
```

## tests\example.spec.js

```js
// @ts-check
import { test, expect } from '@playwright/test';

test('has title', async ({ page }) => {
  await page.goto('/');

  // Expect a title "to contain" a substring.
  await expect(page.getByText('Vite + React + Tailwind')).toBeVisible();
});

test('dark mode toggle works', async ({ page }) => {
  await page.goto('/');
  
  // Click the dark mode toggle button
  await page.getByRole('button', { name: 'Toggle Dark Mode' }).click();

  // Verify dark mode is enabled
  const html = page.locator('html');
  await expect(html).toHaveClass(/dark/);
});

test('counter functionality', async ({ page }) => {
  await page.goto('/');

  // Test increment
  await page.getByRole('button', { name: '+' }).click();
  await expect(page.locator('text=1')).toBeVisible();

  // Test decrement
  await page.getByRole('button', { name: '-' }).click();
  await expect(page.locator('text=0')).toBeVisible();

  // Test reset
  await page.getByRole('button', { name: '+' }).click();
  await page.getByRole('button', { name: '+' }).click();
  await page.getByRole('button', { name: 'Reset' }).click();
  await expect(page.locator('text=0')).toBeVisible();
});
```

## tests\quizflow.spec.js

```js
// @ts-check
import { test, expect } from '@playwright/test';

test.describe('Quiz Application Flow', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
  });

  test('complete quiz journey', async ({ page }) => {
    // 1. Landing page and menu
    await expect(page.getByText('STEAM Career Quiz')).toBeVisible();
    await expect(page.getByText('Welcome to the STEAM Career Quiz')).toBeVisible();
    
    // Start button should be visible and clickable
    const startButton = page.getByRole('button', { name: 'Start Quiz' });
    await expect(startButton).toBeVisible();
    await startButton.click();

    // 2. Username Entry
    const usernameInput = page.getByPlaceholder('Enter your username');
    await expect(usernameInput).toBeVisible();
    await usernameInput.fill('TestUser');
    await page.getByRole('button', { name: 'Continue' }).click();

    // 3. Personality Quiz Section
    await expect(page.getByText('OCEAN Personality Test')).toBeVisible();
    
    // Complete personality questions
    for (let i = 0; i < 25; i++) {
      // Select a random answer between 1-9 for each personality question
      const randomAnswer = Math.floor(Math.random() * 9) + 1;
      await page.getByRole('radio', { name: randomAnswer.toString() }).click();
      await page.getByRole('button', { name: 'Next' }).click();
    }

    // 4. Subject Quiz Section
    await expect(page.getByText('STEAM Subject Quiz')).toBeVisible();
    
    // Complete subject questions (10 questions for each of the 5 subjects)
    for (let i = 0; i < 50; i++) {
      // Select a random answer for each subject question
      const randomAnswer = Math.floor(Math.random() * 4) + 1;
      await page.getByRole('radio', { name: `option${randomAnswer}` }).click();
      await page.getByRole('button', { name: 'Next' }).click();
    }

    // 5. Results Page
    await expect(page.getByText('Your Results')).toBeVisible();
    
    // Check for personality results
    await expect(page.getByText('Personality Profile')).toBeVisible();
    
    // Check for subject results
    await expect(page.getByText('Subject Performance')).toBeVisible();
    
    // Check for career recommendations
    await expect(page.getByText('Career Recommendations')).toBeVisible();

    // 6. Leaderboard
    const viewLeaderboardButton = page.getByRole('button', { name: 'View Leaderboard' });
    await expect(viewLeaderboardButton).toBeVisible();
    await viewLeaderboardButton.click();
    
    await expect(page.getByText('Leaderboard')).toBeVisible();
    await expect(page.getByText('TestUser')).toBeVisible();
  });

  test('username validation', async ({ page }) => {
    await page.goto('/');
    await page.getByRole('button', { name: 'Start Quiz' }).click();

    const usernameInput = page.getByPlaceholder('Enter your username');
    const continueButton = page.getByRole('button', { name: 'Continue' });

    // Test too short username
    await usernameInput.fill('ab');
    await continueButton.click();
    await expect(page.getByText('Username must be at least 3 characters')).toBeVisible();

    // Test too long username
    await usernameInput.fill('verylongusername');
    await continueButton.click();
    await expect(page.getByText('Username must be less than 9 characters')).toBeVisible();

    // Test invalid characters
    await usernameInput.fill('User@123');
    await continueButton.click();
    await expect(page.getByText('Username must only contain letters and numbers')).toBeVisible();

    // Test valid username
    await usernameInput.fill('User123');
    await continueButton.click();
    await expect(page.getByText('OCEAN Personality Test')).toBeVisible();
  });

  test('quiz navigation controls', async ({ page }) => {
    // Start quiz and enter username
    await page.goto('/');
    await page.getByRole('button', { name: 'Start Quiz' }).click();
    await page.getByPlaceholder('Enter your username').fill('TestUser');
    await page.getByRole('button', { name: 'Continue' }).click();

    // Test navigation buttons
    const nextButton = page.getByRole('button', { name: 'Next' });
    await expect(nextButton).toBeDisabled(); // Should be disabled until an answer is selected
    
    // Select an answer and test navigation
    await page.getByRole('radio', { name: '5' }).click();
    await expect(nextButton).toBeEnabled();
    await nextButton.click();

    // Test back navigation
    const backButton = page.getByRole('button', { name: 'Previous' });
    await expect(backButton).toBeVisible();
    await backButton.click();

    // Verify previous answer is still selected
    await expect(page.getByRole('radio', { name: '5' })).toBeChecked();
  });
});
```

## tests\responsive.spec.js

```js
// @ts-check
import { test } from '@playwright/test';
import { takeScreenshots } from './utils/screenshot';

test('capture homepage at all screen sizes', async ({ page }) => {
  await page.goto('/');
  await takeScreenshots(page, 'homepage');
});
```

## tests\utils\screenshot.js

```js
// @ts-check
import { test } from '@playwright/test';
import path from 'path';
import fs from 'fs';

// Tailwind breakpoints
export const screens = {
  xs: 375,
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  '2xl': 1536
};

/**
 * Takes screenshots at different viewport widths
 * @param {import('@playwright/test').Page} page
 * @param {string} pageName - Name of the page being tested
 */
export async function takeScreenshots(page, pageName) {
  // Ensure page-specific screenshots directory exists
  const screenshotDir = path.join(process.cwd(), 'screenshots', pageName);
  if (!fs.existsSync(screenshotDir)) {
    fs.mkdirSync(screenshotDir, { recursive: true });
  } else {
    // Clean existing screenshots in this directory
    const files = fs.readdirSync(screenshotDir);
    files.forEach(file => {
      fs.unlinkSync(path.join(screenshotDir, file));
    });
  }

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');

  // Take screenshots at each breakpoint
  for (const [size, width] of Object.entries(screens)) {
    await page.setViewportSize({
      width,
      height: Math.floor(width * 0.8)
    });

    const filename = `${size}-${width}px-${timestamp}.png`;
    await page.screenshot({
      path: path.join(screenshotDir, filename),
      fullPage: true
    });

    console.log(`ðŸ“¸ Captured ${pageName} at ${width}px (${size})`);
  }
}
```

## tests-examples\demo-todo-app.spec.js

```js
// @ts-check
const { test, expect } = require('@playwright/test');

test.beforeEach(async ({ page }) => {
  await page.goto('https://demo.playwright.dev/todomvc');
});

const TODO_ITEMS = [
  'buy some cheese',
  'feed the cat',
  'book a doctors appointment'
];

test.describe('New Todo', () => {
  test('should allow me to add todo items', async ({ page }) => {
    // create a new todo locator
    const newTodo = page.getByPlaceholder('What needs to be done?');

    // Create 1st todo.
    await newTodo.fill(TODO_ITEMS[0]);
    await newTodo.press('Enter');

    // Make sure the list only has one todo item.
    await expect(page.getByTestId('todo-title')).toHaveText([
      TODO_ITEMS[0]
    ]);

    // Create 2nd todo.
    await newTodo.fill(TODO_ITEMS[1]);
    await newTodo.press('Enter');

    // Make sure the list now has two todo items.
    await expect(page.getByTestId('todo-title')).toHaveText([
      TODO_ITEMS[0],
      TODO_ITEMS[1]
    ]);

    await checkNumberOfTodosInLocalStorage(page, 2);
  });

  test('should clear text input field when an item is added', async ({ page }) => {
    // create a new todo locator
    const newTodo = page.getByPlaceholder('What needs to be done?');

    // Create one todo item.
    await newTodo.fill(TODO_ITEMS[0]);
    await newTodo.press('Enter');

    // Check that input is empty.
    await expect(newTodo).toBeEmpty();
    await checkNumberOfTodosInLocalStorage(page, 1);
  });

  test('should append new items to the bottom of the list', async ({ page }) => {
    // Create 3 items.
    await createDefaultTodos(page);

    // create a todo count locator
    const todoCount = page.getByTestId('todo-count')
  
    // Check test using different methods.
    await expect(page.getByText('3 items left')).toBeVisible();
    await expect(todoCount).toHaveText('3 items left');
    await expect(todoCount).toContainText('3');
    await expect(todoCount).toHaveText(/3/);

    // Check all items in one call.
    await expect(page.getByTestId('todo-title')).toHaveText(TODO_ITEMS);
    await checkNumberOfTodosInLocalStorage(page, 3);
  });
});

test.describe('Mark all as completed', () => {
  test.beforeEach(async ({ page }) => {
    await createDefaultTodos(page);
    await checkNumberOfTodosInLocalStorage(page, 3);
  });

  test.afterEach(async ({ page }) => {
    await checkNumberOfTodosInLocalStorage(page, 3);
  });

  test('should allow me to mark all items as completed', async ({ page }) => {
    // Complete all todos.
    await page.getByLabel('Mark all as complete').check();

    // Ensure all todos have 'completed' class.
    await expect(page.getByTestId('todo-item')).toHaveClass(['completed', 'completed', 'completed']);
    await checkNumberOfCompletedTodosInLocalStorage(page, 3);
  });

  test('should allow me to clear the complete state of all items', async ({ page }) => {
    const toggleAll = page.getByLabel('Mark all as complete');
    // Check and then immediately uncheck.
    await toggleAll.check();
    await toggleAll.uncheck();

    // Should be no completed classes.
    await expect(page.getByTestId('todo-item')).toHaveClass(['', '', '']);
  });

  test('complete all checkbox should update state when items are completed / cleared', async ({ page }) => {
    const toggleAll = page.getByLabel('Mark all as complete');
    await toggleAll.check();
    await expect(toggleAll).toBeChecked();
    await checkNumberOfCompletedTodosInLocalStorage(page, 3);

    // Uncheck first todo.
    const firstTodo = page.getByTestId('todo-item').nth(0);
    await firstTodo.getByRole('checkbox').uncheck();

    // Reuse toggleAll locator and make sure its not checked.
    await expect(toggleAll).not.toBeChecked();

    await firstTodo.getByRole('checkbox').check();
    await checkNumberOfCompletedTodosInLocalStorage(page, 3);

    // Assert the toggle all is checked again.
    await expect(toggleAll).toBeChecked();
  });
});

test.describe('Item', () => {

  test('should allow me to mark items as complete', async ({ page }) => {
    // create a new todo locator
    const newTodo = page.getByPlaceholder('What needs to be done?');

    // Create two items.
    for (const item of TODO_ITEMS.slice(0, 2)) {
      await newTodo.fill(item);
      await newTodo.press('Enter');
    }

    // Check first item.
    const firstTodo = page.getByTestId('todo-item').nth(0);
    await firstTodo.getByRole('checkbox').check();
    await expect(firstTodo).toHaveClass('completed');

    // Check second item.
    const secondTodo = page.getByTestId('todo-item').nth(1);
    await expect(secondTodo).not.toHaveClass('completed');
    await secondTodo.getByRole('checkbox').check();

    // Assert completed class.
    await expect(firstTodo).toHaveClass('completed');
    await expect(secondTodo).toHaveClass('completed');
  });

  test('should allow me to un-mark items as complete', async ({ page }) => {
     // create a new todo locator
     const newTodo = page.getByPlaceholder('What needs to be done?');

    // Create two items.
    for (const item of TODO_ITEMS.slice(0, 2)) {
      await newTodo.fill(item);
      await newTodo.press('Enter');
    }

    const firstTodo = page.getByTestId('todo-item').nth(0);
    const secondTodo = page.getByTestId('todo-item').nth(1);
    const firstTodoCheckbox = firstTodo.getByRole('checkbox');

    await firstTodoCheckbox.check();
    await expect(firstTodo).toHaveClass('completed');
    await expect(secondTodo).not.toHaveClass('completed');
    await checkNumberOfCompletedTodosInLocalStorage(page, 1);

    await firstTodoCheckbox.uncheck();
    await expect(firstTodo).not.toHaveClass('completed');
    await expect(secondTodo).not.toHaveClass('completed');
    await checkNumberOfCompletedTodosInLocalStorage(page, 0);
  });

  test('should allow me to edit an item', async ({ page }) => {
    await createDefaultTodos(page);

    const todoItems = page.getByTestId('todo-item');
    const secondTodo = todoItems.nth(1);
    await secondTodo.dblclick();
    await expect(secondTodo.getByRole('textbox', { name: 'Edit' })).toHaveValue(TODO_ITEMS[1]);
    await secondTodo.getByRole('textbox', { name: 'Edit' }).fill('buy some sausages');
    await secondTodo.getByRole('textbox', { name: 'Edit' }).press('Enter');

    // Explicitly assert the new text value.
    await expect(todoItems).toHaveText([
      TODO_ITEMS[0],
      'buy some sausages',
      TODO_ITEMS[2]
    ]);
    await checkTodosInLocalStorage(page, 'buy some sausages');
  });
});

test.describe('Editing', () => {
  test.beforeEach(async ({ page }) => {
    await createDefaultTodos(page);
    await checkNumberOfTodosInLocalStorage(page, 3);
  });

  test('should hide other controls when editing', async ({ page }) => {
    const todoItem = page.getByTestId('todo-item').nth(1);
    await todoItem.dblclick();
    await expect(todoItem.getByRole('checkbox')).not.toBeVisible();
    await expect(todoItem.locator('label', {
      hasText: TODO_ITEMS[1],
    })).not.toBeVisible();
    await checkNumberOfTodosInLocalStorage(page, 3);
  });

  test('should save edits on blur', async ({ page }) => {
    const todoItems = page.getByTestId('todo-item');
    await todoItems.nth(1).dblclick();
    await todoItems.nth(1).getByRole('textbox', { name: 'Edit' }).fill('buy some sausages');
    await todoItems.nth(1).getByRole('textbox', { name: 'Edit' }).dispatchEvent('blur');

    await expect(todoItems).toHaveText([
      TODO_ITEMS[0],
      'buy some sausages',
      TODO_ITEMS[2],
    ]);
    await checkTodosInLocalStorage(page, 'buy some sausages');
  });

  test('should trim entered text', async ({ page }) => {
    const todoItems = page.getByTestId('todo-item');
    await todoItems.nth(1).dblclick();
    await todoItems.nth(1).getByRole('textbox', { name: 'Edit' }).fill('    buy some sausages    ');
    await todoItems.nth(1).getByRole('textbox', { name: 'Edit' }).press('Enter');

    await expect(todoItems).toHaveText([
      TODO_ITEMS[0],
      'buy some sausages',
      TODO_ITEMS[2],
    ]);
    await checkTodosInLocalStorage(page, 'buy some sausages');
  });

  test('should remove the item if an empty text string was entered', async ({ page }) => {
    const todoItems = page.getByTestId('todo-item');
    await todoItems.nth(1).dblclick();
    await todoItems.nth(1).getByRole('textbox', { name: 'Edit' }).fill('');
    await todoItems.nth(1).getByRole('textbox', { name: 'Edit' }).press('Enter');

    await expect(todoItems).toHaveText([
      TODO_ITEMS[0],
      TODO_ITEMS[2],
    ]);
  });

  test('should cancel edits on escape', async ({ page }) => {
    const todoItems = page.getByTestId('todo-item');
    await todoItems.nth(1).dblclick();
    await todoItems.nth(1).getByRole('textbox', { name: 'Edit' }).fill('buy some sausages');
    await todoItems.nth(1).getByRole('textbox', { name: 'Edit' }).press('Escape');
    await expect(todoItems).toHaveText(TODO_ITEMS);
  });
});

test.describe('Counter', () => {
  test('should display the current number of todo items', async ({ page }) => {
    // create a new todo locator
    const newTodo = page.getByPlaceholder('What needs to be done?');

    // create a todo count locator
    const todoCount = page.getByTestId('todo-count')

    await newTodo.fill(TODO_ITEMS[0]);
    await newTodo.press('Enter');
    await expect(todoCount).toContainText('1');

    await newTodo.fill(TODO_ITEMS[1]);
    await newTodo.press('Enter');
    await expect(todoCount).toContainText('2');

    await checkNumberOfTodosInLocalStorage(page, 2);
  });
});

test.describe('Clear completed button', () => {
  test.beforeEach(async ({ page }) => {
    await createDefaultTodos(page);
  });

  test('should display the correct text', async ({ page }) => {
    await page.locator('.todo-list li .toggle').first().check();
    await expect(page.getByRole('button', { name: 'Clear completed' })).toBeVisible();
  });

  test('should remove completed items when clicked', async ({ page }) => {
    const todoItems = page.getByTestId('todo-item');
    await todoItems.nth(1).getByRole('checkbox').check();
    await page.getByRole('button', { name: 'Clear completed' }).click();
    await expect(todoItems).toHaveCount(2);
    await expect(todoItems).toHaveText([TODO_ITEMS[0], TODO_ITEMS[2]]);
  });

  test('should be hidden when there are no items that are completed', async ({ page }) => {
    await page.locator('.todo-list li .toggle').first().check();
    await page.getByRole('button', { name: 'Clear completed' }).click();
    await expect(page.getByRole('button', { name: 'Clear completed' })).toBeHidden();
  });
});

test.describe('Persistence', () => {
  test('should persist its data', async ({ page }) => {
    // create a new todo locator
    const newTodo = page.getByPlaceholder('What needs to be done?');

    for (const item of TODO_ITEMS.slice(0, 2)) {
      await newTodo.fill(item);
      await newTodo.press('Enter');
    }

    const todoItems = page.getByTestId('todo-item');
    const firstTodoCheck = todoItems.nth(0).getByRole('checkbox');
    await firstTodoCheck.check();
    await expect(todoItems).toHaveText([TODO_ITEMS[0], TODO_ITEMS[1]]);
    await expect(firstTodoCheck).toBeChecked();
    await expect(todoItems).toHaveClass(['completed', '']);

    // Ensure there is 1 completed item.
    await checkNumberOfCompletedTodosInLocalStorage(page, 1);

    // Now reload.
    await page.reload();
    await expect(todoItems).toHaveText([TODO_ITEMS[0], TODO_ITEMS[1]]);
    await expect(firstTodoCheck).toBeChecked();
    await expect(todoItems).toHaveClass(['completed', '']);
  });
});

test.describe('Routing', () => {
  test.beforeEach(async ({ page }) => {
    await createDefaultTodos(page);
    // make sure the app had a chance to save updated todos in storage
    // before navigating to a new view, otherwise the items can get lost :(
    // in some frameworks like Durandal
    await checkTodosInLocalStorage(page, TODO_ITEMS[0]);
  });

  test('should allow me to display active items', async ({ page }) => {
    const todoItem = page.getByTestId('todo-item');
    await page.getByTestId('todo-item').nth(1).getByRole('checkbox').check();
    
    await checkNumberOfCompletedTodosInLocalStorage(page, 1);
    await page.getByRole('link', { name: 'Active' }).click();
    await expect(todoItem).toHaveCount(2);
    await expect(todoItem).toHaveText([TODO_ITEMS[0], TODO_ITEMS[2]]);
  });

  test('should respect the back button', async ({ page }) => {
    const todoItem = page.getByTestId('todo-item');
    await page.getByTestId('todo-item').nth(1).getByRole('checkbox').check();

    await checkNumberOfCompletedTodosInLocalStorage(page, 1);

    await test.step('Showing all items', async () => {
      await page.getByRole('link', { name: 'All' }).click();
      await expect(todoItem).toHaveCount(3);
    });

    await test.step('Showing active items', async () => {
      await page.getByRole('link', { name: 'Active' }).click();
    });

    await test.step('Showing completed items', async () => {
      await page.getByRole('link', { name: 'Completed' }).click();
    });

    await expect(todoItem).toHaveCount(1);
    await page.goBack();
    await expect(todoItem).toHaveCount(2);
    await page.goBack();
    await expect(todoItem).toHaveCount(3);
  });

  test('should allow me to display completed items', async ({ page }) => {
    await page.getByTestId('todo-item').nth(1).getByRole('checkbox').check();
    await checkNumberOfCompletedTodosInLocalStorage(page, 1);
    await page.getByRole('link', { name: 'Completed' }).click();
    await expect(page.getByTestId('todo-item')).toHaveCount(1);
  });

  test('should allow me to display all items', async ({ page }) => {
    await page.getByTestId('todo-item').nth(1).getByRole('checkbox').check();
    await checkNumberOfCompletedTodosInLocalStorage(page, 1);
    await page.getByRole('link', { name: 'Active' }).click();
    await page.getByRole('link', { name: 'Completed' }).click();
    await page.getByRole('link', { name: 'All' }).click();
    await expect(page.getByTestId('todo-item')).toHaveCount(3);
  });

  test('should highlight the currently applied filter', async ({ page }) => {
    await expect(page.getByRole('link', { name: 'All' })).toHaveClass('selected');

    //create locators for active and completed links
    const activeLink = page.getByRole('link', { name: 'Active' });
    const completedLink = page.getByRole('link', { name: 'Completed' });
    await activeLink.click();

    // Page change - active items.
    await expect(activeLink).toHaveClass('selected');
    await completedLink.click();

    // Page change - completed items.
    await expect(completedLink).toHaveClass('selected');
  });
});

async function createDefaultTodos(page) {
  // create a new todo locator
  const newTodo = page.getByPlaceholder('What needs to be done?');

  for (const item of TODO_ITEMS) {
    await newTodo.fill(item);
    await newTodo.press('Enter');
  }
}

/**
 * @param {import('@playwright/test').Page} page
 * @param {number} expected
 */
 async function checkNumberOfTodosInLocalStorage(page, expected) {
  return await page.waitForFunction(e => {
    return JSON.parse(localStorage['react-todos']).length === e;
  }, expected);
}

/**
 * @param {import('@playwright/test').Page} page
 * @param {number} expected
 */
 async function checkNumberOfCompletedTodosInLocalStorage(page, expected) {
  return await page.waitForFunction(e => {
    return JSON.parse(localStorage['react-todos']).filter(i => i.completed).length === e;
  }, expected);
}

/**
 * @param {import('@playwright/test').Page} page
 * @param {string} title
 */
async function checkTodosInLocalStorage(page, title) {
  return await page.waitForFunction(t => {
    return JSON.parse(localStorage['react-todos']).map(i => i.title).includes(t);
  }, title);
}

```

## vite.config.js

```js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from "tailwindcss";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  css: {
   postcss: {
    plugins: [tailwindcss],
   },
  },
});

```

